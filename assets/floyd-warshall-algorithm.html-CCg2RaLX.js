import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as l,o as n}from"./app-C9ucjmrR.js";const t={};function e(h,i){return n(),a("div",null,i[0]||(i[0]=[l(`<h2 id="什么是-floyd-warshall-算法" tabindex="-1"><a class="header-anchor" href="#什么是-floyd-warshall-算法"><span>什么是 Floyd-Warshall 算法？</span></a></h2><p>Floyd-Warshall 算法（简称 Floyd 算法）是一种用于计算 <strong>所有顶点对之间最短路径</strong> 的算法。与 Dijkstra 和 SPFA 不同，它不是单源最短路算法，而是一次性计算出图中任意两点之间的最短距离。</p><p>Floyd 算法可以正确处理带有 <strong>负权边</strong> 的图，但不能处理带有 <strong>负环</strong> 的图。它非常适合用于稠密图。</p><h2 id="核心思想-动态规划" tabindex="-1"><a class="header-anchor" href="#核心思想-动态规划"><span>核心思想：动态规划</span></a></h2><p>Floyd 算法的本质是一个动态规划。我们定义一个二维数组 <code>dp[k][i][j]</code>，表示从顶点 <code>i</code> 到顶点 <code>j</code>，只允许经过编号从 <code>1</code> 到 <code>k</code> 的顶点作为中间点时，所能得到的最短路径长度。</p><p>状态转移方程如下： <code>dp[k][i][j] = min(dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j])</code></p><p>这个方程的含义是：从 <code>i</code> 到 <code>j</code>，若只允许经过 <code>1...k</code> 作为中间点，其最短路径有两种可能：</p><ol><li>不经过顶点 <code>k</code>，那么最短路径就是 <code>dp[k-1][i][j]</code>。</li><li>经过顶点 <code>k</code>，那么路径就被分为 <code>i -&gt; k</code> 和 <code>k -&gt; j</code> 两段，最短路径就是这两段之和 <code>dp[k-1][i][k] + dp[k-1][k][j]</code>。</li></ol><p>我们在这两种可能中取一个最小值。</p><p>由于 <code>dp[k]</code> 的计算只依赖于 <code>dp[k-1]</code>，我们可以通过滚动数组的思想，将 <code>k</code> 这一维度优化掉，得到一个更简洁的二维形式。</p><h2 id="算法流程" tabindex="-1"><a class="header-anchor" href="#算法流程"><span>算法流程</span></a></h2><ol><li><p><strong>初始化:</strong></p><ul><li>创建一个二维数组 <code>dist[i][j]</code>，用于存储任意两点 <code>i</code> 和 <code>j</code> 之间的最短距离。</li><li>如果 <code>i</code> 和 <code>j</code> 之间有直接的边，则 <code>dist[i][j]</code> 等于该边的权重。</li><li>如果 <code>i == j</code>，则 <code>dist[i][j] = 0</code>。</li><li>其他情况，<code>dist[i][j]</code> 为无穷大。</li></ul></li><li><p><strong>三重循环:</strong></p><ul><li>最外层循环 <code>k</code> 从 <code>1</code> 到 <code>N</code>（<code>k</code> 是作为中间点的顶点）。</li><li>内两层循环 <code>i</code> 从 <code>1</code> 到 <code>N</code> 和 <code>j</code> 从 <code>1</code> 到 <code>N</code>。</li><li>在循环中，执行松弛操作：<code>dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])</code>。</li></ul></li></ol><p>循环结束后，<code>dist[i][j]</code> 中存储的就是从 <code>i</code> 到 <code>j</code> 的最短路径长度。</p><h2 id="c-伪代码" tabindex="-1"><a class="header-anchor" href="#c-伪代码"><span>C++ 伪代码</span></a></h2><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;vector&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;algorithm&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> INF </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">e</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">9</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 一个足够大的数</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> floydWarshall</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">vector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">vector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> dist</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // dist 数组需要预先初始化</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // dist[i][j] = weight if edge (i,j) exists</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // dist[i][i] = 0</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // dist[i][j] = INF otherwise</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> k </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; k </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n; </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">k) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n; </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">i) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> j </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; j </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n; </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">j) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">dist</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[i][k] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">!=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> INF </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> dist</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[k][j] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">!=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> INF) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                    dist</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[i][j] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">min</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">dist</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[i][j], </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">dist</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[i][k] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> dist</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[k][j]);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析"><span>复杂度分析</span></a></h2><ul><li><strong>时间复杂度:</strong> O(N³)，其中 N 是顶点数。这个复杂度使得它不适用于非常大的图。</li><li><strong>空间复杂度:</strong> O(N²)。</li></ul><p>Floyd 算法以其代码简洁、逻辑清晰而著称，是解决全源最短路问题的标准方法。</p>`,18)]))}const p=s(t,[["render",e]]),r=JSON.parse('{"path":"/posts/floyd-warshall-algorithm.html","title":"图论算法：Floyd-Warshall 算法","lang":"en-US","frontmatter":{"title":"图论算法：Floyd-Warshall 算法","date":"2024-07-27T00:00:00.000Z","category":"算法","tags":["算法","图论","最短路","Floyd","动态规划"],"description":"什么是 Floyd-Warshall 算法？ Floyd-Warshall 算法（简称 Floyd 算法）是一种用于计算 所有顶点对之间最短路径 的算法。与 Dijkstra 和 SPFA 不同，它不是单源最短路算法，而是一次性计算出图中任意两点之间的最短距离。 Floyd 算法可以正确处理带有 负权边 的图，但不能处理带有 负环 的图。它非常适合用于...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"图论算法：Floyd-Warshall 算法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-27T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aiden L.\\",\\"url\\":\\"https://aidenljk.github.io\\",\\"email\\":\\"aidenljkliu@gmail.com\\"}]}"],["meta",{"property":"og:url","content":"https://aidenljk.github.io/posts/floyd-warshall-algorithm.html"}],["meta",{"property":"og:title","content":"图论算法：Floyd-Warshall 算法"}],["meta",{"property":"og:description","content":"什么是 Floyd-Warshall 算法？ Floyd-Warshall 算法（简称 Floyd 算法）是一种用于计算 所有顶点对之间最短路径 的算法。与 Dijkstra 和 SPFA 不同，它不是单源最短路算法，而是一次性计算出图中任意两点之间的最短距离。 Floyd 算法可以正确处理带有 负权边 的图，但不能处理带有 负环 的图。它非常适合用于..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:tag","content":"动态规划"}],["meta",{"property":"article:tag","content":"Floyd"}],["meta",{"property":"article:tag","content":"最短路"}],["meta",{"property":"article:tag","content":"图论"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2024-07-27T00:00:00.000Z"}]]},"git":{},"readingTime":{"minutes":2.51,"words":753},"filePathRelative":"posts/floyd-warshall-algorithm.md","excerpt":"<h2>什么是 Floyd-Warshall 算法？</h2>\\n<p>Floyd-Warshall 算法（简称 Floyd 算法）是一种用于计算 <strong>所有顶点对之间最短路径</strong> 的算法。与 Dijkstra 和 SPFA 不同，它不是单源最短路算法，而是一次性计算出图中任意两点之间的最短距离。</p>\\n<p>Floyd 算法可以正确处理带有 <strong>负权边</strong> 的图，但不能处理带有 <strong>负环</strong> 的图。它非常适合用于稠密图。</p>\\n<h2>核心思想：动态规划</h2>\\n<p>Floyd 算法的本质是一个动态规划。我们定义一个二维数组 <code>dp[k][i][j]</code>，表示从顶点 <code>i</code> 到顶点 <code>j</code>，只允许经过编号从 <code>1</code> 到 <code>k</code> 的顶点作为中间点时，所能得到的最短路径长度。</p>","autoDesc":true}');export{p as comp,r as data};
