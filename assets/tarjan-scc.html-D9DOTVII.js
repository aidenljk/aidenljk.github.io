import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as n,o as e}from"./app-C9ucjmrR.js";const l={};function t(h,s){return e(),a("div",null,s[0]||(s[0]=[n(`<h2 id="什么是强连通分量-scc" tabindex="-1"><a class="header-anchor" href="#什么是强连通分量-scc"><span>什么是强连通分量 (SCC)？</span></a></h2><p>在有向图中，如果两个顶点 <code>u</code> 和 <code>v</code> 能相互到达（即存在从 <code>u</code> 到 <code>v</code> 的路径，也存在从 <code>v</code> 到 <code>u</code> 的路径），则称这两个顶点是强连通的。强连通是顶点之间的一种等价关系。有向图中的极大强连通子图，被称为强连通分量 (Strongly Connected Components, SCC)。</p><h2 id="tarjan-算法的核心思想" tabindex="-1"><a class="header-anchor" href="#tarjan-算法的核心思想"><span>Tarjan 算法的核心思想</span></a></h2><p>Tarjan 算法是一个基于深度优先搜索 (DFS) 的算法，它能在 O(V+E) 的时间内找出有向图中的所有强连通分量。</p><p>算法为每个节点 <code>u</code> 维护两个关键的变量：</p><ul><li><code>dfn[u]</code>: 深度优先搜索中 <code>u</code> 被访问到的时间戳（顺序编号）。</li><li><code>low[u]</code>: <code>u</code> 节点（以及其 DFS 树中的子树）能够通过 <strong>最多一条非树边</strong>（返祖边或横叉边）追溯到的、在栈中最早的节点的 <code>dfn</code> 值。</li></ul><p>算法还使用一个栈来保存当前正在访问的路径上的节点。</p><h2 id="算法步骤" tabindex="-1"><a class="header-anchor" href="#算法步骤"><span>算法步骤</span></a></h2><ol><li>初始化 <code>dfn</code> 和 <code>low</code> 数组，以及一���空栈 <code>s</code>。</li><li>从任意未访问过的节点开始进行 DFS 遍历。</li><li>对于当前访问的节点 <code>u</code>： a. 设置 <code>dfn[u] = low[u] = ++timestamp</code>。 b. 将 <code>u</code> 压入栈 <code>s</code> 中，并标记为在栈中。 c. 遍历 <code>u</code> 的每一个邻居 <code>v</code>： i. 如果 <code>v</code> 未被访问过，则递归调用 <code>tarjan(v)</code>，然后用 <code>v</code> 的 <code>low</code> 值更新 <code>u</code> 的 <code>low</code> 值：<code>low[u] = min(low[u], low[v])</code>。 ii. 如果 <code>v</code> 已经被访问过 <strong>且在栈中</strong>，说明找到了一条返祖边，用 <code>v</code> 的 <code>dfn</code> 值更新 <code>u</code> 的 <code>low</code> 值：<code>low[u] = min(low[u], dfn[v])</code>。</li><li>当 DFS 从 <code>u</code> 回溯前，检查是否有 <code>dfn[u] == low[u]</code>。 <ul><li>如果成立，说明 <code>u</code> 是它所在强连通分量的“根”。</li><li>此时，从栈顶不断弹出元素，直到 <code>u</code> 被弹出。所有这些被弹出的节点共同构成一个强连通分量。</li></ul></li></ol><h2 id="伪代码" tabindex="-1"><a class="header-anchor" href="#伪代码"><span>伪代码</span></a></h2><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> tarjan</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">u</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">):</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  dfn</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[u] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> low</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[u] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">timestamp</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  stack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">push</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(u)</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  in_stack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[u] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> each </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">edge</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (u, v):</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> v is </span><span style="--shiki-light:#A626A4;--shiki-dark:#ABB2BF;">not</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> visited:</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">      tarjan</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(v)</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">      low</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[u] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> min</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">low</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[u], </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">low</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[v])</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    else</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> v is in_stack:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">      low</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[u] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> min</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">low</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[u], </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">dfn</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[v])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> dfn</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[u] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> low</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[u]:</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // u is the root of an SCC</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    create a </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> SCC</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      v </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> stack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pop</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">      in_stack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[v] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      add v to current SCC</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">      if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> u </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> v:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        break</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Tarjan 算法是图论中一个非常优美且高效的算法，常用于缩点等操作，是解决复杂图问题的基础。</p>`,12)]))}const k=i(l,[["render",t]]),r=JSON.parse('{"path":"/posts/tarjan-scc.html","title":"图算法：Tarjan 算法求强连通分量","lang":"en-US","frontmatter":{"title":"图算法：Tarjan 算法求强连通分量","date":"2024-07-20T00:00:00.000Z","category":"算法","tags":["算法","图","Tarjan","强连通分量"],"description":"什么是强连通分量 (SCC)？ 在有向图中，如果两个顶点 u 和 v 能相互到达（即存在从 u 到 v 的路径，也存在从 v 到 u 的路径），则称这两个顶点是强连通的。强连通是顶点之间的一种等价关系。有向图中的极大强连通子图，被称为强连通分量 (Strongly Connected Components, SCC)。 Tarjan 算法的核心思想 T...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"图算法：Tarjan 算法求强连通分量\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-20T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aiden L.\\",\\"url\\":\\"https://aidenljk.github.io\\",\\"email\\":\\"aidenljkliu@gmail.com\\"}]}"],["meta",{"property":"og:url","content":"https://aidenljk.github.io/posts/tarjan-scc.html"}],["meta",{"property":"og:title","content":"图算法：Tarjan 算法求强连通分量"}],["meta",{"property":"og:description","content":"什么是强连通分量 (SCC)？ 在有向图中，如果两个顶点 u 和 v 能相互到达（即存在从 u 到 v 的路径，也存在从 v 到 u 的路径），则称这两个顶点是强连通的。强连通是顶点之间的一种等价关系。有向图中的极大强连通子图，被称为强连通分量 (Strongly Connected Components, SCC)。 Tarjan 算法的核心思想 T..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:tag","content":"强连通分量"}],["meta",{"property":"article:tag","content":"Tarjan"}],["meta",{"property":"article:tag","content":"图"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2024-07-20T00:00:00.000Z"}]]},"git":{},"readingTime":{"minutes":2.14,"words":641},"filePathRelative":"posts/tarjan-scc.md","excerpt":"<h2>什么是强连通分量 (SCC)？</h2>\\n<p>在有向图中，如果两个顶点 <code>u</code> 和 <code>v</code> 能相互到达（即存在从 <code>u</code> 到 <code>v</code> 的路径，也存在从 <code>v</code> 到 <code>u</code> 的路径），则称这两个顶点是强连通的。强连通是顶点之间的一种等价关系。有向图中的极大强连通子图，被称为强连通分量 (Strongly Connected Components, SCC)。</p>\\n<h2>Tarjan 算法的核心思想</h2>\\n<p>Tarjan 算法是一个基于深度优先搜索 (DFS) 的算法，它能在 O(V+E) 的时间内找出有向图中的所有强连通分量。</p>","autoDesc":true}');export{k as comp,r as data};
