import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as n,o as t}from"./app-C9ucjmrR.js";const l={};function h(e,i){return t(),a("div",null,i[0]||(i[0]=[n(`<h2 id="什么是动态规划" tabindex="-1"><a class="header-anchor" href="#什么是动态规划"><span>什么是动态规划？</span></a></h2><p>动态规划（DP）是一种通过将原问题分解为相互重叠的子问题来解决复杂问题的算法思想。它通常用于优化问题，通过存储子问题的解来避免重复计算。</p><h2 id="核心要素" tabindex="-1"><a class="header-anchor" href="#核心要素"><span>核心要素</span></a></h2><ol><li><strong>最优子结构:</strong> 问题的最优解包含了其子问题的最优解。</li><li><strong>重叠子问题:</strong> 在求解过程中，许多子问题被反复计算。DP 通过存储这些解来提高效率。</li><li><strong>状态转移方程:</strong> 定义了问题状态之间如何转换的数学表达式。</li></ol><h2 id="经典问题-斐波那契数列" tabindex="-1"><a class="header-anchor" href="#经典问题-斐波那契数列"><span>经典问题：斐波那契数列</span></a></h2><p>未使用 DP (递归):</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fib</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fib</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fib</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 大量重复计算</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 DP (自底向上):</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;vector&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> fib_dp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::vector</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;int&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> dp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(n </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    dp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    dp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n; i</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        dp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[i] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> dp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> dp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> dp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[n];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="解题步骤" tabindex="-1"><a class="header-anchor" href="#解题步骤"><span>解题步骤</span></a></h2><ol><li><strong>定义状态:</strong> 确定 <code>dp[i]</code> 或 <code>dp[i][j]</code> 代表什么。</li><li><strong>找出状态转移方程:</strong> 这是最关键的一步。</li><li><strong>初始化:</strong> 确定 DP 表的初始值。</li><li><strong>确定遍历顺序:</strong> 保证计算当前状态时，所依赖的状态已经被计算过。</li></ol><p>动态规划是一种强大的技术，但需要大量的练习才能熟练掌握。</p>`,12)]))}const r=s(l,[["render",h]]),d=JSON.parse('{"path":"/posts/dynamic-programming.html","title":"算法思想：动态规划 (Dynamic Programming)","lang":"en-US","frontmatter":{"title":"算法思想：动态规划 (Dynamic Programming)","date":"2024-07-11T00:00:00.000Z","category":"算法","tags":["算法","动态规划","DP"],"description":"什么是动态规划？ 动态规划（DP）是一种通过将原问题分解为相互重叠的子问题来解决复杂问题的算法思想。它通常用于优化问题，通过存储子问题的解来避免重复计算。 核心要素 最优子结构: 问题的最优解包含了其子问题的最优解。 重叠子问题: 在求解过程中，许多子问题被反复计算。DP 通过存储这些解来提高效率。 状态转移方程: 定义了问题状态之间如何转换的数学表达...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"算法思想：动态规划 (Dynamic Programming)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-11T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aiden L.\\",\\"url\\":\\"https://aidenljk.github.io\\",\\"email\\":\\"aidenljkliu@gmail.com\\"}]}"],["meta",{"property":"og:url","content":"https://aidenljk.github.io/posts/dynamic-programming.html"}],["meta",{"property":"og:title","content":"算法思想：动态规划 (Dynamic Programming)"}],["meta",{"property":"og:description","content":"什么是动态规划？ 动态规划（DP）是一种通过将原问题分解为相互重叠的子问题来解决复杂问题的算法思想。它通常用于优化问题，通过存储子问题的解来避免重复计算。 核心要素 最优子结构: 问题的最优解包含了其子问题的最优解。 重叠子问题: 在求解过程中，许多子问题被反复计算。DP 通过存储这些解来提高效率。 状态转移方程: 定义了问题状态之间如何转换的数学表达..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:tag","content":"DP"}],["meta",{"property":"article:tag","content":"动态规划"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2024-07-11T00:00:00.000Z"}]]},"git":{},"readingTime":{"minutes":1.25,"words":376},"filePathRelative":"posts/dynamic-programming.md","excerpt":"<h2>什么是动态规划？</h2>\\n<p>动态规划（DP）是一种通过将原问题分解为相互重叠的子问题来解决复杂问题的算法思想。它通常用于优化问题，通过存储子问题的解来避免重复计算。</p>\\n<h2>核心要素</h2>\\n<ol>\\n<li><strong>最优子结构:</strong> 问题的最优解包含了其子问题的最优解。</li>\\n<li><strong>重叠子问题:</strong> 在求解过程中，许多子问题被反复计算。DP 通过存储这些解来提高效率。</li>\\n<li><strong>状态转移方程:</strong> 定义了问题状态之间如何转换的数学表达式。</li>\\n</ol>\\n<h2>经典问题：斐波那契数列</h2>","autoDesc":true}');export{r as comp,d as data};
