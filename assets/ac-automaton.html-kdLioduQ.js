import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as c,o as i}from"./app-C9ucjmrR.js";const a={};function r(n,e){return i(),t("div",null,e[0]||(e[0]=[c('<h2 id="什么是-ac-自动机" tabindex="-1"><a class="header-anchor" href="#什么是-ac-自动机"><span>什么是 AC 自动机？</span></a></h2><p>AC 自动机（Aho-Corasick Automaton）是一种高效的、基于字典树（Trie）和 KMP 思想的字符串匹配算法。它能够在一个主文本串中，同时查找多个模式串的存在，且时间复杂度为线性 O(N+M)，其中 N 是主文本串长度，M 是所有模式串的总长度。</p><h2 id="核心思想" tabindex="-1"><a class="header-anchor" href="#核心思想"><span>核心思想</span></a></h2><p>AC 自动机巧妙地结合了两种数据结构的优点：</p><ol><li><strong>Trie (字典树):</strong> 用来存储所有的模式串。Trie 的结构使得所有模式串共享公共前缀，节省了空间。</li><li><strong>失败指针 (Fail Pointer):</strong> 这是 AC 自动机的精髓，类似于 KMP 算法中的 <code>next</code> 数组。每个 Trie 节点都有一个失败指针。节点 <code>u</code> 的失败指针指向的节点 <code>v</code>，代表了从根到 <code>v</code> 的路径所形成的字符串，是“从根到 <code>u</code> 的路径所形成的字符串”的 <strong>最长真后缀</strong>，并且这个后缀本身也是一个模式串的前缀。</li></ol><p>当在主文本串中匹配时，如果当前字符无法在 Trie 树上继续前进（即 <code>Trie[current_node][char]</code> 不存在），我们就顺���当前节点的失败指针往回跳，直到找到一个可以匹配当前字符的节点，或者跳回根节点。这个过程保证了匹配不会中断，并且能发现所有可能存在的模式串。</p><h2 id="算法构建流程" tabindex="-1"><a class="header-anchor" href="#算法构建流程"><span>算法构建流程</span></a></h2><ol><li><strong>构建 Trie:</strong> 将所有模式串插入到一个 Trie 树中。在每个模式串的结尾节点，标记这是一个模式串的结束。</li><li><strong>构建失败指针:</strong><ul><li>使用广度优先搜索 (BFS) 来按层构建失败指针。</li><li>根节点的失败指针指向自己（或 null）。</li><li>对于队列中取出的节点 <code>u</code>，遍历其所有子节点 <code>v</code>（对应字符 <code>c</code>）： <ul><li>找到 <code>u</code> 的失败指针指向的节点 <code>p_fail = u-&gt;fail</code>。</li><li>在 <code>p_fail</code> 节点上，尝试沿着字符 <code>c</code> 前进。如果 <code>Trie[p_fail][c]</code> 存在，那么 <code>v</code> 的失败指针就指向 <code>Trie[p_fail][c]</code>。</li><li>如果 <code>Trie[p_fail][c]</code> 不存在，就继续跳 <code>p_fail = p_fail-&gt;fail</code>，重复此过程，直到找到或者跳回根节点。</li><li>将 <code>v</code> 加入队列。</li></ul></li></ul></li></ol><h2 id="匹配流程" tabindex="-1"><a class="header-anchor" href="#匹配流程"><span>匹配流程</span></a></h2><ol><li>从 Trie 的根节点开始，遍历主文本串的每一个字符 <code>c</code>。</li><li>在当前节点 <code>p</code>，沿着字符 <code>c</code> 在 Trie 树上移动。如果 <code>Trie[p][c]</code> 不存在，则令 <code>p = p-&gt;fail</code> 并重复，直到找到或回到根。</li><li>移动到新节点 <code>p_new</code> 后��从 <code>p_new</code> 开始，沿着失败指针链一直跳回根节点。路径上遇到的所有被标记为“模式串结尾”的节点，都代表一个成功的匹配。</li></ol><p>AC 自动机是多模式串匹配问题的最优解法之一，在文本过滤、生物信息学等领域有广泛应用。</p>',11)]))}const p=o(a,[["render",r]]),s=JSON.parse('{"path":"/posts/ac-automaton.html","title":"字符串算法：AC 自动机","lang":"en-US","frontmatter":{"title":"字符串算法：AC 自动机","date":"2024-07-22T00:00:00.000Z","category":"算法","tags":["算法","字符串","AC自动机","自动机"],"description":"什么是 AC 自动机？ AC 自动机（Aho-Corasick Automaton）是一种高效的、基于字典树（Trie）和 KMP 思想的字符串匹配算法。它能够在一个主文本串中，同时查找多个模式串的存在，且时间复杂度为线性 O(N+M)，其中 N 是主文本串长度，M 是所有模式串的总长度。 核心思想 AC 自动机巧妙地结合了两种数据结构的优点： Tri...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"字符串算法：AC 自动机\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-22T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aiden L.\\",\\"url\\":\\"https://aidenljk.github.io\\",\\"email\\":\\"aidenljkliu@gmail.com\\"}]}"],["meta",{"property":"og:url","content":"https://aidenljk.github.io/posts/ac-automaton.html"}],["meta",{"property":"og:title","content":"字符串算法：AC 自动机"}],["meta",{"property":"og:description","content":"什么是 AC 自动机？ AC 自动机（Aho-Corasick Automaton）是一种高效的、基于字典树（Trie）和 KMP 思想的字符串匹配算法。它能够在一个主文本串中，同时查找多个模式串的存在，且时间复杂度为线性 O(N+M)，其中 N 是主文本串长度，M 是所有模式串的总长度。 核心思想 AC 自动机巧妙地结合了两种数据结构的优点： Tri..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:tag","content":"自动机"}],["meta",{"property":"article:tag","content":"AC自动机"}],["meta",{"property":"article:tag","content":"字符串"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2024-07-22T00:00:00.000Z"}]]},"git":{},"readingTime":{"minutes":2.52,"words":757},"filePathRelative":"posts/ac-automaton.md","excerpt":"<h2>什么是 AC 自动机？</h2>\\n<p>AC 自动机（Aho-Corasick Automaton）是一种高效的、基于字典树（Trie）和 KMP 思想的字符串匹配算法。它能够在一个主文本串中，同时查找多个模式串的存在，且时间复杂度为线性 O(N+M)，其中 N 是主文本串长度，M 是所有模式串的总长度。</p>\\n<h2>核心思想</h2>\\n<p>AC 自动机巧妙地结合了两种数据结构的优点：</p>\\n<ol>\\n<li><strong>Trie (字典树):</strong> 用来存储所有的模式串。Trie 的结构使得所有模式串共享公共前缀，节省了空间。</li>\\n<li><strong>失败指针 (Fail Pointer):</strong> 这是 AC 自动机的精髓，类似于 KMP 算法中的 <code>next</code> 数组。每个 Trie 节点都有一个失败指针。节点 <code>u</code> 的失败指针指向的节点 <code>v</code>，代表了从根到 <code>v</code> 的路径所形成的字符串，是“从根到 <code>u</code> 的路径所形成的字符串”的 <strong>最长真后缀</strong>，并且这个后缀本身也是一个模式串的前缀。</li>\\n</ol>","autoDesc":true}');export{p as comp,s as data};
