import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,d as a,o as i}from"./app-C9ucjmrR.js";const t={};function l(p,n){return i(),s("div",null,n[0]||(n[0]=[a(`<h2 id="什么是线段树分治" tabindex="-1"><a class="header-anchor" href="#什么是线段树分治"><span>什么是线段树分治？</span></a></h2><p>线段树分治是一种离线处理问题的强大技巧。它适用于一类问题：存在一系列操作（或查询），每个操作只在某个时间段内有效。我们无法高效地在线处理这些有时效性的操作，但可以离线地将所有操作和查询读入，然后利用线段树的结构来处理它们。</p><h2 id="核心思想" tabindex="-1"><a class="header-anchor" href="#核心思想"><span>核心思想</span></a></h2><p>我们将时间轴看作一个大的区间，然后建立一棵线段树。对于每一个有时效性的操作（例如，在时间 <code>[t_start, t_end]</code> 内添加一条边），我们不直接执行它，而是将这个操作“挂”在线段树上对应的 <code>log(T)</code> 个节点上。</p><p>具体步骤如下：</p><ol><li><strong>建立时间线段树:</strong> 根据总时间范围 <code>[1, T]</code> 建立一棵线段树。</li><li><strong>添加操作:</strong> 对于每个在 <code>[t_start, t_end]</code> 时间段内有效的操作，我们在线段树上进行区间更新，将该操作的 ID 添加到完全覆盖 <code>[t_start, t_end]</code> 的线段树节点的列表中。</li><li><strong>DFS 遍历:</strong> 对整个线段树进行一次深度优先搜索 (DFS)。 <ul><li>当我们进入一个节点时，执行该节点上挂的所有操作（例如，用并查集连接边）。</li><li>递归地处理左子节点和右子节点。</li><li>当我们离开一个节点时，撤销在该节点上执行的操作，恢复现场（例如，用可撤销并查集断开边）。</li><li>如果当前节点是叶子节点，说明我们到达了某个具体的时间点，此时处理该时间点的所有查询。</li></ul></li></ol><h2 id="伪代码" tabindex="-1"><a class="header-anchor" href="#伪代码"><span>伪代码</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>function solve(node, l, r):</span></span>
<span class="line"><span>  // 应用当前节点的操作</span></span>
<span class="line"><span>  for op in node.operations:</span></span>
<span class="line"><span>    apply(op)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  if l == r:</span></span>
<span class="line"><span>    // 处理时间点 l 的所有查询</span></span>
<span class="line"><span>    for query in queries_at_time[l]:</span></span>
<span class="line"><span>      answer(query)</span></span>
<span class="line"><span>  else:</span></span>
<span class="line"><span>    mid = (l + r) / 2</span></span>
<span class="line"><span>    solve(node.left, l, mid)</span></span>
<span class="line"><span>    solve(node.right, mid + 1, r)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 撤销当前节点的操作</span></span>
<span class="line"><span>  for op in node.operations:</span></span>
<span class="line"><span>    undo(op)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="关键优势" tabindex="-1"><a class="header-anchor" href="#关键优势"><span>关键优势</span></a></h2><ul><li><strong>降维:</strong> 将一个带时间维度的动态问题，转化为一个离线的、静态的、可以通过 DFS 解决的问题。</li><li><strong>适用性广:</strong> 常与并查集、凸包、线性基等数据结构结合，解决动态图连通性、动态凸包等复杂问题。</li><li><strong>撤销操作:</strong> 核心是数据结构必须支持高效的“撤销”操作。可撤销并查集是其经典搭档。</li></ul><p>线段树分治是一种优雅的暴力，它用一个 <code>log</code> 的代价，将操作的影响范围精确地分配到各个时间点，是处理带时间区间的离线问题的利器。</p>`,11)]))}const d=e(t,[["render",l]]),c=JSON.parse('{"path":"/posts/segment-tree-divide-and-conquer.html","title":"进阶算法：线段树分治","lang":"en-US","frontmatter":{"title":"进阶算法：线段树分治","date":"2024-07-17T00:00:00.000Z","category":"算法","tags":["算法","数据结构","线段树","分治"],"description":"什么是线段树分治？ 线段树分治是一种离线处理问题的强大技巧。它适用于一类问题：存在一系列操作（或查询），每个操作只在某个时间段内有效。我们无法高效地在线处理这些有时效性的操作，但可以离线地将所有操作和查询读入，然后利用线段树的结构来处理它们。 核心思想 我们将时间轴看作一个大的区间，然后建立一棵线段树。对于每一个有时效性的操作（例如，在时间 [t_st...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"进阶算法：线段树分治\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-17T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aiden L.\\",\\"url\\":\\"https://aidenljk.github.io\\",\\"email\\":\\"aidenljkliu@gmail.com\\"}]}"],["meta",{"property":"og:url","content":"https://aidenljk.github.io/posts/segment-tree-divide-and-conquer.html"}],["meta",{"property":"og:title","content":"进阶算法：线段树分治"}],["meta",{"property":"og:description","content":"什么是线段树分治？ 线段树分治是一种离线处理问题的强大技巧。它适用于一类问题：存在一系列操作（或查询），每个操作只在某个时间段内有效。我们无法高效地在线处理这些有时效性的操作，但可以离线地将所有操作和查询读入，然后利用线段树的结构来处理它们。 核心思想 我们将时间轴看作一个大的区间，然后建立一棵线段树。对于每一个有时效性的操作（例如，在时间 [t_st..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:tag","content":"分治"}],["meta",{"property":"article:tag","content":"线段树"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2024-07-17T00:00:00.000Z"}]]},"git":{},"readingTime":{"minutes":2.33,"words":698},"filePathRelative":"posts/segment-tree-divide-and-conquer.md","excerpt":"<h2>什么是线段树分治？</h2>\\n<p>线段树分治是一种离线处理问题的强大技巧。它适用于一类问题：存在一系列操作（或查询），每个操作只在某个时间段内有效。我们无法高效地在线处理这些有时效性的操作，但可以离线地将所有操作和查询读入，然后利用线段树的结构来处理它们。</p>\\n<h2>核心思想</h2>\\n<p>我们将时间轴看作一个大的区间，然后建立一棵线段树。对于每一个有时效性的操作（例如，在时间 <code>[t_start, t_end]</code> 内添加一条边），我们不直接执行它，而是将这个操作“挂”在线段树上对应的 <code>log(T)</code> 个节点上。</p>\\n<p>具体步骤如下：</p>","autoDesc":true}');export{d as comp,c as data};
