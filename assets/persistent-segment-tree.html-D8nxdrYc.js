import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as c,o as d}from"./app-C9ucjmrR.js";const r={};function i(n,e){return d(),t("div",null,e[0]||(e[0]=[c('<h2 id="什么叫-可持久化" tabindex="-1"><a class="header-anchor" href="#什么叫-可持久化"><span>什么叫“可持久化”？</span></a></h2><p>在算法竞赛中，“可持久化”通常指一种数据结构技术，它允许我们在修改数据结构后，仍然能访问到修改前（即历史版本）的数据。</p><h2 id="主席树的核心思想" tabindex="-1"><a class="header-anchor" href="#主席树的核心思想"><span>主席树的核心思想</span></a></h2><p>主席树，又称可持久化（权值）线段树，是可持久化思想的经典应用。它通过巧妙地复用节点，实现了在保持历史版本的同时，高效地创建新版本。</p><p>当我们对线段树进行单点修改时，从根节点到目标叶子节点的路径上，最多只有 <code>log(N)</code> 个节点会发生改变。可持久化的思想就是：<strong>只创建这 <code>log(N)</code> 个新的节点，而路径上其他未改变的节点，则直接链接到旧版本的对应节点上。</strong></p><p>每次修改都会产生一个新的树根（Root），代表一个新的版本。通过保存这些不同的树根，我们就能访问任意历史版本的线段树。</p><h2 id="结构示意" tabindex="-1"><a class="header-anchor" href="#结构示意"><span>结构示意</span></a></h2><p>假设我们修改了版本 <code>i</code> 的某个值，得到版本 <code>j</code>：</p><ul><li>版本 <code>i</code> 的根是 <code>root[i]</code>。</li><li>版本 <code>j</code> 的根是 <code>root[j]</code>。</li><li><code>root[j]</code> 会复制 <code>root[i]</code> 的信息，并根据修改路径创建新的节点。如果修改在左子树，那么 <code>root[j]</code> 的右儿子就直接指向 <code>root[i]</code> 的右儿子，而左儿子则指向一个新创建的节点。这个过程递归地进行下去。</li></ul><p>由于每次修改只增加 <code>log(N)</code> 个新节点，所以 <code>M</code> 次修改后的总空间复杂度是 <code>O(N + M log N)</code>，非常高效。</p><h2 id="经典应用-静态区间第-k-小" tabindex="-1"><a class="header-anchor" href="#经典应用-静态区间第-k-小"><span>经典应用：静态区间第 K 小</span></a></h2><p>主席树最经典的应用就是解决静态区间的第 K 小问题。</p><ol><li><strong>离散化:</strong> 将所有数值进行离散化。</li><li><strong>建树:</strong><ul><li>我们对原始数组的 <strong>前缀</strong> 建立权值线段树。</li><li>第 <code>i</code> 个版本的线段树 (<code>root[i]</code>) 存储的是原数组 <code>a[1...i]</code> 中各个数值出现的次数。</li><li>版本 <code>i</code> 的线段树是通过在版本 <code>i-1</code> 的基础上，对 <code>a[i]</code> 的值进行一次单点更新得到的。</li></ul></li><li><strong>查询 <code>[L, R]</code> 区间的第 K 小:</strong><ul><li>利用线段树的可减性，我们可以通过 <code>root[R]</code> 和 <code>root[L-1]</code> 这两个版本的信息，来得到区间 <code>[L, R]</code> 的权值线段树。</li><li>具体来说，<code>root[R]</code> 的某个节点值减去 <code>root[L-1]</code> 的对应节点值，就等于 <code>a[L...R]</code> 中落在这个值域区间的数的个数。</li><li>我们可以在这两棵树上同步进行类似权值线段树��查询第 K 小的操作。如果左子树的数的个数 <code>count</code> 大于等于 <code>k</code>，我们就往左走；否则，我们就往右走，并查询第 <code>k - count</code> 小。</li></ul></li></ol><p>主席树是处理可持久化问题和区间问题的强大工具，是数据结构进阶路上必须掌握的一环。</p>',14)]))}const p=o(r,[["render",i]]),s=JSON.parse('{"path":"/posts/persistent-segment-tree.html","title":"进阶数据结构：主席树（可持久化线段树）","lang":"en-US","frontmatter":{"title":"进阶数据结构：主席树（可持久化线段树）","date":"2024-07-18T00:00:00.000Z","category":"数据结构","tags":["数据结构","可持久化","线段树","主席树"],"description":"什么叫“可持久化”？ 在算法竞赛中，“可持久化”通常指一种数据结构技术，它允许我们在修改数据结构后，仍然能访问到修改前（即历史版本）的数据。 主席树的核心思想 主席树，又称可持久化（权值）线段树，是可持久化思想的经典应用。它通过巧妙地复用节点，实现了在保持历史版本的同时，高效地创建新版本。 当我们对线段树进行单点修改时，从根节点到目标叶子节点的路径上，...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"进阶数据结构：主席树（可持久化线段树）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-18T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aiden L.\\",\\"url\\":\\"https://aidenljk.github.io\\",\\"email\\":\\"aidenljkliu@gmail.com\\"}]}"],["meta",{"property":"og:url","content":"https://aidenljk.github.io/posts/persistent-segment-tree.html"}],["meta",{"property":"og:title","content":"进阶数据结构：主席树（可持久化线段树）"}],["meta",{"property":"og:description","content":"什么叫“可持久化”？ 在算法竞赛中，“可持久化”通常指一种数据结构技术，它允许我们在修改数据结构后，仍然能访问到修改前（即历史版本）的数据。 主席树的核心思想 主席树，又称可持久化（权值）线段树，是可持久化思想的经典应用。它通过巧妙地复用节点，实现了在保持历史版本的同时，高效地创建新版本。 当我们对线段树进行单点修改时，从根节点到目标叶子节点的路径上，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:tag","content":"主席树"}],["meta",{"property":"article:tag","content":"线段树"}],["meta",{"property":"article:tag","content":"可持久化"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:published_time","content":"2024-07-18T00:00:00.000Z"}]]},"git":{},"readingTime":{"minutes":2.63,"words":790},"filePathRelative":"posts/persistent-segment-tree.md","excerpt":"<h2>什么叫“可持久化”？</h2>\\n<p>在算法竞赛中，“可持久化”通常指一种数据结构技术，它允许我们在修改数据结构后，仍然能访问到修改前（即历史版本）的数据。</p>\\n<h2>主席树的核心思想</h2>\\n<p>主席树，又称可持久化（权值）线段树，是可持久化思想的经典应用。它通过巧妙地复用节点，实现了在保持历史版本的同时，高效地创建新版本。</p>\\n<p>当我们对线段树进行单点修改时，从根节点到目标叶子节点的路径上，最多只有 <code>log(N)</code> 个节点会发生改变。可持久化的思想就是：<strong>只创建这 <code>log(N)</code> 个新的节点，而路径上其他未改变的节点，则直接链接到旧版本的对应节点上。</strong></p>","autoDesc":true}');export{p as comp,s as data};
