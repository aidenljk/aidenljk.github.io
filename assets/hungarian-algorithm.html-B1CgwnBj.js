import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as n,o as e}from"./app-C9ucjmrR.js";const l={};function t(h,s){return e(),a("div",null,s[0]||(s[0]=[n(`<h2 id="什么是二分图最大匹配" tabindex="-1"><a class="header-anchor" href="#什么是二分图最大匹配"><span>什么是二分图最大匹配？</span></a></h2><ul><li><strong>二分图:</strong> 一个图的顶点可以被分为两个独立的集合 <code>U</code> 和 <code>V</code>，使得所有的边都连接 <code>U</code> 和 <code>V</code> 中的顶点，而 <code>U</code> 或 <code>V</code> 内部没有边。</li><li><strong>匹配:</strong> 图中的一个边的集合，其中任意两条边都没有公共的顶点。</li><li><strong>最大匹配:</strong> 一个图中，包含边数最多的匹配。</li></ul><p>二分图最大匹配问题就是要在二分图中找到一个边数最多的匹配。这个问题在任务分配、资源调度等场景中有广泛应用。</p><h2 id="匈牙利算法的核心思想" tabindex="-1"><a class="header-anchor" href="#匈牙利算法的核心思想"><span>匈牙利算法的核心思想</span></a></h2><p>匈牙利算法是一种基于 <strong>增广路 (Augmenting Path)</strong> 的算法。</p><ul><li><strong>增广路:</strong> 一条在图中的路径，其起始点和终点都是未匹配的顶点，并且路径上的边是“未匹配边”和“已匹配边”交替出现的。</li></ul><p><strong>增广路定理:</strong> 一个匹配是最大匹配，当且仅当图中不存在增广路。</p><p>匈牙利算法的核心思想就是不断地在图中寻找增广路。每找到一条增广路，我们就可以沿着这条路，将路径上的“未匹配边”变为“已匹配边”，将“已匹配边”变为“未匹配边”。这个操作被称为 <strong>路径取反</strong>。</p><p>路径取反后，新的匹配中边的数量会比原来多一条。因此，我们只需要持续寻找增广路并进行路径取反，直到图中再也找不到增广路为止。此时，得到的匹配就是最大匹配。</p><h2 id="算法流程" tabindex="-1"><a class="header-anchor" href="#算法流程"><span>算法流程</span></a></h2><p>算法通常对左边的集合 <code>U</code> 中的每个顶点 <code>u</code> 进行一次尝试：</p><ol><li>初始化所有顶点为未匹配状态。</li><li>遍历 <code>U</code> 中的每一个顶点 <code>u</code>： a. 为 <code>u</code> 寻找一条增广路。这通常通过一次深度优先搜索 (DFS) 或广度优先搜索 (BFS) 来实现。 b. 在一次为 <code>u</code> 寻找增广路的过程中，为了防止重复访问，需要一个 <code>visited</code> 数组。 c. DFS 过程 <code>find_path(curr_u)</code>: i. 遍历 <code>curr_u</code> 的所有邻居 <code>v</code>。 ii. 如果 <code>v</code> 在本次为 <code>u</code> 的查找中未被访问过： - 标记 <code>v</code> 为已访问。 - 如果 <code>v</code> 是一个未匹配的顶点，或者 <code>v</code> 已经匹配了，但从 <code>v</code> 的匹配对象 <code>match[v]</code> 出发能找到一条增广路（即 <code>find_path(match[v])</code> 为真），那么我们就找到了一条从 <code>curr_u</code> 开始的增广路。 - 此时，更新匹配关系 <code>match[v] = curr_u</code>，并返回 <code>true</code>。 d. 如果为 <code>u</code> 找到了增广路，则总匹配数加一。</li></ol><h2 id="c-伪代码" tabindex="-1"><a class="header-anchor" href="#c-伪代码"><span>C++ 伪代码</span></a></h2><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">vector</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;int&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> adj</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[MAX_U];</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> match</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[MAX_V];</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">bool</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> visited</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[MAX_U];</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> u_size, v_size;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">bool</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> dfs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> u</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> v : </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">adj</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[u]) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">visited</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[v]) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            visited</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[v] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">match</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[v] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> ||</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> dfs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">match</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[v])) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                match</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[v] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> u;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> hungarian</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> result </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    memset</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(match, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(match));</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> u </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; u </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> u_size; </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">u) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        memset</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(visited, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(visited));</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">dfs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(u)) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            result</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> result;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>匈牙利算法虽然名字听起来很复杂，但其核心的增广路思想相对直观，是解决二分图匹配问题的经典方法。</p>`,15)]))}const d=i(l,[["render",t]]),r=JSON.parse('{"path":"/posts/hungarian-algorithm.html","title":"图论算法：匈牙利算法","lang":"en-US","frontmatter":{"title":"图论算法：匈牙利算法","date":"2024-07-25T00:00:00.000Z","category":"算法","tags":["算法","图论","二分图","匹配","匈牙利算法"],"description":"什么是二分图最大匹配？ 二分图: 一个图的顶点可以被分为两个独立的集合 U 和 V，使得所有的边都连接 U 和 V 中的顶点，而 U 或 V 内部没有边。 匹配: 图中的一个边的集合，其中任意两条边都没有公共的顶点。 最大匹配: 一个图中，包含边数最多的匹配。 二分图最大匹配问题就是要在二分图中找到一个边数最多的匹配。这个问题在任务分配、资源调度等场景...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"图论算法：匈牙利算法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-25T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aiden L.\\",\\"url\\":\\"https://aidenljk.github.io\\",\\"email\\":\\"aidenljkliu@gmail.com\\"}]}"],["meta",{"property":"og:url","content":"https://aidenljk.github.io/posts/hungarian-algorithm.html"}],["meta",{"property":"og:title","content":"图论算法：匈牙利算法"}],["meta",{"property":"og:description","content":"什么是二分图最大匹配？ 二分图: 一个图的顶点可以被分为两个独立的集合 U 和 V，使得所有的边都连接 U 和 V 中的顶点，而 U 或 V 内部没有边。 匹配: 图中的一个边的集合，其中任意两条边都没有公共的顶点。 最大匹配: 一个图中，包含边数最多的匹配。 二分图最大匹配问题就是要在二分图中找到一个边数最多的匹配。这个问题在任务分配、资源调度等场景..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:tag","content":"匈牙利算法"}],["meta",{"property":"article:tag","content":"匹配"}],["meta",{"property":"article:tag","content":"二分图"}],["meta",{"property":"article:tag","content":"图论"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2024-07-25T00:00:00.000Z"}]]},"git":{},"readingTime":{"minutes":2.7,"words":809},"filePathRelative":"posts/hungarian-algorithm.md","excerpt":"<h2>什么是二分图最大匹配？</h2>\\n<ul>\\n<li><strong>二分图:</strong> 一个图的顶点可以被分为两个独立的集合 <code>U</code> 和 <code>V</code>，使得所有的边都连接 <code>U</code> 和 <code>V</code> 中的顶点，而 <code>U</code> 或 <code>V</code> 内部没有边。</li>\\n<li><strong>匹配:</strong> 图中的一个边的集合，其中任意两条边都没有公共的顶点。</li>\\n<li><strong>最大匹配:</strong> 一个图中，包含边数最多的匹配。</li>\\n</ul>","autoDesc":true}');export{d as comp,r as data};
