import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c,d as t,o as d}from"./app-C9ucjmrR.js";const n={};function a(i,e){return d(),c("div",null,e[0]||(e[0]=[t('<h2 id="什么是后缀自动机-sam" tabindex="-1"><a class="header-anchor" href="#什么是后缀自动机-sam"><span>什么是后缀自动机 (SAM)？</span></a></h2><p>后缀自动机（Suffix Automaton, SAM）是一个强大而精巧的数据结构，它能接受一个字符串 <code>S</code> 的所有后缀。更神奇的是，它实际上也接受了 <code>S</code> 的 <strong>所有子串</strong>。SAM 是一个既包含字符串所有子串信息，又具有最小节点和边数的有向无环图（DAG）。</p><p>对于一个长度为 <code>n</code> 的字符串，SAM 的空间复杂度和在线构建的时间复杂度都是线性的 O(n)。</p><h2 id="核心概念" tabindex="-1"><a class="header-anchor" href="#核心概念"><span>核心概念</span></a></h2><ol><li><strong>状态 (State):</strong> SAM 中的每个节点代表一个状态，每个状态对应着原字符串中一个或多个子串的集合。</li><li><strong>转移 (Transition):</strong> 状态之间的有向边代表字符的转移。从状态 <code>u</code> 到 <code>v</code> 有一条字符 <code>c</code> 的转移边，表示在 <code>u</code> 所代表的子串集合中的所有字符串末尾添加字符 <code>c</code> 后，得到的新字符串都属于 <code>v</code> 所代表的子串集合。</li><li><strong>后缀链接 (Suffix Link):</strong> 这是 SAM 最核心的概念之一。每��非初始状态都有一个后缀链接，指向另一个状态。状态 <code>u</code> 的后缀链接指向状态 <code>v</code>，表示 <code>v</code> 所代表的子串集合是 <code>u</code> 所代表的子串集合中 <strong>所有字符串</strong> 的 <strong>最长后缀</strong>，且这些后缀也存在于 <code>v</code> 的子串集合中。所有后缀链接最终都会指向初始状态，形成一棵树状结构（Parent Tree）。</li></ol><h2 id="sam-的性质" tabindex="-1"><a class="header-anchor" href="#sam-的性质"><span>SAM 的性质</span></a></h2><ul><li>SAM 是一个 DAG，状态数和转移数都是线性的。</li><li>从初始状态出发的任意一条路径，都对应着原字符串的一个子串。</li><li>一个字符串是 <code>S</code> 的子串，当且仅当它能被 SAM 接受。</li><li>在 Parent Tree 上，一个节点的祖先节点们代表了该节点所有子串的后缀。</li></ul><h2 id="构建算法" tabindex="-1"><a class="header-anchor" href="#构建算法"><span>构建算法</span></a></h2><p>SAM 的构建是一个在线算法，即逐个添加字符串的字符来构建。假设我们已经为字符串 <code>S</code> 构建好了 SAM，现在要添加一个新字符 <code>c</code> 形成 <code>Sc</code>。</p><p>构建过程大致如下：</p><ol><li>创建一个新状态 <code>cur</code> 代表整个新串 <code>Sc</code>。</li><li>找到代表旧串 <code>S</code> 的状态 <code>last</code>。</li><li>从 <code>last</code> 开始，沿着后缀链接往回跳。如果当前节点没有字符 <code>c</code> 的转移，就添加一条到 <code>cur</code> 的转移。</li><li>如果跳回到了初始状态，说明字符 <code>c</code> 从未出现过，<code>cur</code> 的后缀链接直接指向初始状态。</li><li>如果在某个节点 <code>p</code> 找到���字符 <code>c</code> 的转移，指向状态 <code>q</code>，情况会变得复杂： <ul><li>如果 <code>len[q] == len[p] + 1</code>，说明 <code>q</code> 对应的最长串就是 <code>p</code> 后面接个 <code>c</code>，是 <code>Sc</code> 的一个后缀。直接将 <code>cur</code> 的后缀链接指向 <code>q</code> 即可。</li><li>否则，情况最复杂。这意味着 <code>q</code> 不仅代表了 <code>Sc</code> 的后缀，还代表了其他更长的、不是 <code>Sc</code> 后缀的子串。此时需要“分裂”状态 <code>q</code>：创建一个新的克隆状态 <code>clone</code>，复制 <code>q</code> 的信息，但 <code>len[clone]</code> 设为 <code>len[p] + 1</code>。然后将 <code>q</code> 和 <code>cur</code> 的后缀链接都指向 <code>clone</code>，并重定向一些旧的转移到 <code>clone</code> 上。</li></ul></li></ol><h2 id="应用" tabindex="-1"><a class="header-anchor" href="#应用"><span>应用</span></a></h2><p>SAM 在字符串问题中应用极其广泛，例如：</p><ul><li>检查一个串是否是另一个串的子串。</li><li>计算不同子串的数量。</li><li>计算所有子串的总长度。</li><li>字典序第 k 大子串。</li></ul><p>掌握 SAM 需要对字符串和自动机有较深的理解，但它无疑是解决子串相关问题的最强工具之一。</p>',15)]))}const s=o(n,[["render",a]]),p=JSON.parse('{"path":"/posts/suffix-automaton.html","title":"字符串算法：后缀自动机 (SAM) 简介","lang":"en-US","frontmatter":{"title":"字符串算法：后缀自动机 (SAM) 简介","date":"2024-07-24T00:00:00.000Z","category":"算法","tags":["算法","字符串","后缀自动机","SAM","自动机"],"description":"什么是后缀自动机 (SAM)？ 后缀自动机（Suffix Automaton, SAM）是一个强大而精巧的数据结构，它能接受一个字符串 S 的所有后缀。更神奇的是，它实际上也接受了 S 的 所有子串。SAM 是一个既包含字符串所有子串信息，又具有最小节点和边数的有向无环图（DAG）。 对于一个长度为 n 的字符串，SAM 的空间复杂度和在线构建的时间复...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"字符串算法：后缀自动机 (SAM) 简介\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-24T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aiden L.\\",\\"url\\":\\"https://aidenljk.github.io\\",\\"email\\":\\"aidenljkliu@gmail.com\\"}]}"],["meta",{"property":"og:url","content":"https://aidenljk.github.io/posts/suffix-automaton.html"}],["meta",{"property":"og:title","content":"字符串算法：后缀自动机 (SAM) 简介"}],["meta",{"property":"og:description","content":"什么是后缀自动机 (SAM)？ 后缀自动机（Suffix Automaton, SAM）是一个强大而精巧的数据结构，它能接受一个字符串 S 的所有后缀。更神奇的是，它实际上也接受了 S 的 所有子串。SAM 是一个既包含字符串所有子串信息，又具有最小节点和边数的有向无环图（DAG）。 对于一个长度为 n 的字符串，SAM 的空间复杂度和在线构建的时间复..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:tag","content":"自动机"}],["meta",{"property":"article:tag","content":"SAM"}],["meta",{"property":"article:tag","content":"后缀自动机"}],["meta",{"property":"article:tag","content":"字符串"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2024-07-24T00:00:00.000Z"}]]},"git":{},"readingTime":{"minutes":3.19,"words":956},"filePathRelative":"posts/suffix-automaton.md","excerpt":"<h2>什么是后缀自动机 (SAM)？</h2>\\n<p>后缀自动机（Suffix Automaton, SAM）是一个强大而精巧的数据结构，它能接受一个字符串 <code>S</code> 的所有后缀。更神奇的是，它实际上也接受了 <code>S</code> 的 <strong>所有子串</strong>。SAM 是一个既包含字符串所有子串信息，又具有最小节点和边数的有向无环图（DAG）。</p>\\n<p>对于一个长度为 <code>n</code> 的字符串，SAM 的空间复杂度和在线构建的时间复杂度都是线性的 O(n)。</p>\\n<h2>核心概念</h2>\\n<ol>\\n<li><strong>状态 (State):</strong> SAM 中的每个节点代表一个状态，每个状态对应着原字符串中一个或多个子串的集合。</li>\\n<li><strong>转移 (Transition):</strong> 状态之间的有向边代表字符的转移。从状态 <code>u</code> 到 <code>v</code> 有一条字符 <code>c</code> 的转移边，表示在 <code>u</code> 所代表的子串集合中的所有字符串末尾添加字符 <code>c</code> 后，得到的新字符串都属于 <code>v</code> 所代表的子串集合。</li>\\n<li><strong>后缀链接 (Suffix Link):</strong> 这是 SAM 最核心的概念之一。每��非初始状态都有一个后缀链接，指向另一个状态。状态 <code>u</code> 的后缀链接指向状态 <code>v</code>，表示 <code>v</code> 所代表的子串集合是 <code>u</code> 所代表的子串集合中 <strong>所有字符串</strong> 的 <strong>最长后缀</strong>，且这些后缀也存在于 <code>v</code> 的子串集合中。所有后缀链接最终都会指向初始状态，形成一棵树状结构（Parent Tree）。</li>\\n</ol>","autoDesc":true}');export{s as comp,p as data};
